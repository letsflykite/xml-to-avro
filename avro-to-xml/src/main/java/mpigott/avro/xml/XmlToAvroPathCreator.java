/**
 * Copyright 2014 Mike Pigott
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mpigott.avro.xml;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.namespace.QName;

import org.apache.ws.commons.schema.XmlSchemaAny;
import org.apache.ws.commons.schema.XmlSchemaContentProcessing;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * Performs a SAX-based walk through the XML document, determining the
 * interpretation ("path") that best matches both the XML Schema and the
 * Avro Schema.
 *
 * @author  Mike Pigott
 */
final class XmlToAvroPathCreator extends DefaultHandler {

  /* If a group loops back on itself, we don't want to loop
   * until the stack overflows looking for a valid match.
   * We will stop looking once we reach MAX_DEPTH.
   */
  private static final int MAX_DEPTH = 256;

  /* We want to keep track of all of the valid path segments to a particular
   * element, but we do not want to stomp on the very first node until we
   * know which path we want to follow.  Likewise, we want to keep the
   * first node in the segment without a "next" node, but every node after
   * that we wish to chain together.
   *
   * To accomplish this, we start with a base node at the end and "prepend"
   * previous nodes until we work our way back to the beginning.  When we
   * prepend a node, we link the previous start node to the node directly
   * after it, while leaving the new start node unlinked.
   *
   * Path segments may also be recycled when a decision point is refuted.
   */
  private final class PathSegment implements Comparable<PathSegment> {
    PathSegment(XmlSchemaDocumentPathNode node) {
      set(node);
    }

    /**
     * The hash code is generated by walking all of the nodes in the path and
     * fetching a hash code for all of those, then summing it all together.
     */
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = prime + start.hashCode();

      if (afterStart != null) {
        for (XmlSchemaDocumentPathNode iter = afterStart;
            iter != null;
            iter = iter.getNext()) {
          result = prime * result + iter.hashCode();
        }
      }

      return result;
    }

    /**
     * Equality is checked by walking all of the nodes
     * in the path and checking equality on every node.
     */
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if (obj == null) {
        return false;
      } else if (!(obj instanceof PathSegment)) {
        return false;
      }

      final PathSegment other = (PathSegment) obj;

      if (start != other.getStart()) {
        /* PathSegments are implemented such that all common PathSegments
         * share the same start node in memory, but all following nodes in
         * the path are clones of each other.  Likewise, if the first nodes
         * do not point to the same memory location, these two paths cannot
         * be equivalent.
         */
        return false;

      } else if ((afterStart == null) && (other.getAfterStart() != null)) {
        return false;
      } else if ((afterStart != null) && (other.getAfterStart() == null)) {
        return false;
      } else if ((afterStart == null) && (other.getAfterStart() == null)) {
        return true;
      }

      XmlSchemaDocumentPathNode thisIter = afterStart;
      XmlSchemaDocumentPathNode thatIter = other.getAfterStart();

      while (thisIter != null) {
        if (thatIter == null) {
          return false;
        } else if ( !thisIter.equals(thatIter) ) {
          return false;
        }

        thisIter = thisIter.getNext();
        thatIter = thatIter.getNext();
      }

      if (thatIter != null) {
        return false;
      }

      return true;
    }

    @Override
    public int compareTo(PathSegment o) {
      if (this == o) {
        return 0;
      }

      /* Paths which end in a wildcard element are of lower
       * rank (higher order) than those that end in elements.
       */
      if ( !end
              .getStateMachineNode()
              .getNodeType()
              .equals( o.getEnd().getStateMachineNode().getNodeType() ) ) {

        if ( end
              .getStateMachineNode()
              .equals(SchemaStateMachineNode.Type.ANY) ) {
          return 1;

        } else if ( o.getEnd()
                     .getStateMachineNode()
                     .getNodeType()
                     .equals(SchemaStateMachineNode.Type.ANY) ) {
          return -1;

        } else {
          throw new IllegalStateException("The end nodes do not have the same machine node type, so one should be an ELEMENT and the other should be an ANY.  However, this end node is a " + end.getStateMachineNode().getNodeType() + " while the other has an end node of type " + o.getEnd().getStateMachineNode().getNodeType() + ".");
        }
      }

      // Shorter paths are preferred over longer ones.
      final int thisLength = getLength();
      final int thatLength = o.getLength();

      if (thisLength < thatLength) {
        return -1;
      } else if (thisLength > thatLength) {
        return 1;
      }

      /* If both paths are the same length, check if one starts with
       * an earlier child in a sequence group than a later child.
       */
      if (thisLength > 0) {
        // Both paths have more than just one element.
        XmlSchemaDocumentPathNode thisIter = afterStart;
        XmlSchemaDocumentPathNode thatIter = o.getAfterStart();

        while (thisIter != null) {
          if (thisIter.getIndexOfNextNodeState()
                < thatIter.getIndexOfNextNodeState()) {
            return -1;

          } else if (thisIter.getIndexOfNextNodeState()
                       > thatIter.getIndexOfNextNodeState()) {
            return  1;
          }

          thisIter = thisIter.getNext();
          thatIter = thatIter.getNext();
        }
      } else {
        if (end.getIndexOfNextNodeState()
              < o.getEnd().getIndexOfNextNodeState()) {

          return -1;

        } else if (end.getIndexOfNextNodeState()
                     > o.getEnd().getIndexOfNextNodeState()) {

          return 1;
        }
      }

      /* If all of our different heuristics do not differentiate the
       * paths, we will return equality.  This is fine because
       * Collections.sort(List<T>) is stable, and will preserve the
       * ordering.
       */
      return 0;
    }

    int getLength() {
      if ((length == 0) && (start != end)) {
        for (XmlSchemaDocumentPathNode iter = afterStart;
            iter != end;
            iter = iter.getNext()) {
          ++length;
        }
        ++length; // (afterStart -> end) + start
      }
      return length;
    }

    /* Prepends a new start node to this segment.  We want to clone
     * the previous start node as sibling paths may be sharing it.
     * We also need to know the newStart's path index to reach the
     * clonedStartNode, so we know how to properly link them later.
     */
    void prepend(XmlSchemaDocumentPathNode newStart, int pathIndexToNextNode) {
      // We need to clone start and make it the afterStart.
      final XmlSchemaDocumentPathNode clonedStartNode =
          createDocumentPathNode(
              start.getDirection(),
              start.getPrevious(),
              start.getDocumentNode());

      if (afterStart != null) {
        afterStart.setPreviousNode(clonedStartNode);
        clonedStartNode.setNextNode(afterStartPathIndex, afterStart);
        afterStart = clonedStartNode;

      } else {
        // This path segment only has one node in it; now it has two.
        end = clonedStartNode;
        afterStart = clonedStartNode;
      }

      start = newStart;
      afterStartPathIndex = pathIndexToNextNode;
      length = 0; // Force a recalculation.
    }

    XmlSchemaDocumentPathNode getStart() {
      return start;
    }

    XmlSchemaDocumentPathNode getEnd() {
      return end;
    }

    XmlSchemaDocumentPathNode getAfterStart() {
      return afterStart;
    }

    int getAfterStartPathIndex() {
      return afterStartPathIndex;
    }

    final void set(XmlSchemaDocumentPathNode node) {
      if (node == null) {
        throw new IllegalArgumentException("DocumentPathNode cannot be null.");
      }

      this.start = node;
      this.end = node;
      this.afterStart = null;
      this.afterStartPathIndex = -1;
      this.length = 0;
    }

    private XmlSchemaDocumentPathNode start;
    private XmlSchemaDocumentPathNode end;
    private XmlSchemaDocumentPathNode afterStart;
    private int length;
    private int afterStartPathIndex;
  }

  /**
   * A <code>DescisionPoint</code> is a location in a document path where
   * an element in the document can be reached by following two or more
   * different traversals through the XML Schema.
   *
   * When we reach such a decision point, we will keep track of the different
   * paths through the XML Schema that reach the element.  We will then follow
   * each path, one-by-one from the shortest through the longest, until we find
   * a path that successfully navigates both the document and the schema.
   */
  private static class DecisionPoint {
    DecisionPoint(
        XmlSchemaDocumentPathNode decisionPoint,
        List<PathSegment> choices,
        int traversedElementIndex) {

      if (decisionPoint == null) {
        throw new IllegalArgumentException("The decision point path node cannot be null.");
      } else if (choices == null) {
        throw new IllegalArgumentException("The set of choice paths to follow cannot be null.");
      } else if (choices.size() < 2) {
        throw new IllegalArgumentException("There must be at least two choices to constitute a decision point, not " + choices.size());
      }

      this.decisionPoint = decisionPoint;
      this.choices = choices;
      this.traversedElementIndex = traversedElementIndex;
      java.util.Collections.sort(choices);
    }

    /**
     * Returns the next <code>PathSegment</code> to try, or
     * <code>null</code> if all <code>PathSegment</code>s
     * have been followed.
     */
    PathSegment tryNextPath() {
      if (choices.isEmpty()) {
        return null;
      } else {
        return choices.remove(0);
      }
    }

    XmlSchemaDocumentPathNode getDecisionPoint() {
      return decisionPoint;
    }

    private final XmlSchemaDocumentPathNode decisionPoint;
    private final List<PathSegment> choices;
    private final int traversedElementIndex;
  }

  private static class TraversedElement {
    enum Traversal {
      START,
      END
    }

    TraversedElement(QName elemName, Traversal traversal) {
      this.elemName = elemName;
      this.traversal = traversal;
    }

    public String toString() {
      StringBuilder str = new StringBuilder( elemName.toString() );
      str.append(" : ").append(traversal);
      return str.toString();
    }

    QName elemName;
    Traversal traversal;
  }

  /**
   * Creates a new <code>XmlToAvroPathCreator</code> with the root
   * {@link SchemaStateMachineNode} to start from when evaluating documents.
   */
  XmlToAvroPathCreator(SchemaStateMachineNode root) {
    rootNode = root;
    rootTreeNode = new XmlSchemaDocumentNode(rootNode);

    rootPathNode =
        new XmlSchemaDocumentPathNode(
            XmlSchemaDocumentPathNode.Direction.CHILD,
            rootTreeNode);

    traversedElements = new ArrayList<TraversedElement>();
    currentPosition = null;
    currentPath = null;
    decisionPoints = null; // Hopefully there won't be any!

    unusedNodePool = null;
    unusedTreePool = null;
    unusedPathSegmentPool = null;
  }

  @Override
  public void startDocument() throws SAXException {
    currentPosition = null;
    currentPath = null;

    traversedElements.clear();

    if (decisionPoints != null) {
      decisionPoints.clear();
    }
  }

  /**
   * Find the path through the XML Schema that best matches this element.
   *
   * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
   */
  @Override
  public void startElement(
      String uri,
      String localName,
      String qName,
      Attributes atts) throws SAXException {

    final QName elemQName = new QName(uri, localName);

    try {
      if ((currentPosition == null) && (currentPath == null)) {
        /* We just started a new document.  Likewise we need
         * to move into a position to process the root element.
         */
        currentPosition = rootTreeNode;
        currentPath = rootPathNode;

      } else if (currentPosition
                   .getStateMachineNode()
                   .getNodeType()
                   .equals(SchemaStateMachineNode.Type.ANY)) {
        /* If we are currently following a wildcard element node, we don't know
         * anything about the element or its children.  So it does not make
         * sense to follow the children or grandchildren of this element.
         */
        return;

      } else {
        /* We are at an element in an existing document.  This
         * is the start node of a child.  Likewise we need to
         * move down one level to the children.
         */
        verifyCurrentPositionIsAtElement("Started element " + elemQName);

        if (currentPosition
             .getStateMachineNode()
             .getPossibleNextStates() != null) {
          
          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has null children!  Exactly one is expected.");

        } else if (!currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates()
                  .isEmpty()) {
          
          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has zero children!  Exactly one is expected.");

        } else if (currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates().size() > 1) {

          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has " + currentPosition.getStateMachineNode().getPossibleNextStates().size() + " children!  Only one was expected.");
        }

        final XmlSchemaDocumentNode childNode =
            createTreeNode(
                currentPosition,
                currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates()
                  .get(0));

        final XmlSchemaDocumentPathNode childPath =
            createDocumentPathNode(
                XmlSchemaDocumentPathNode.Direction.CHILD,
                currentPath,
                childNode);

        currentPosition.getChildren().add(childNode);
        currentPosition = childNode;

        currentPath.setNextNode(0, childPath);
        currentPath = childPath;
      }

      final SchemaStateMachineNode state =
          currentPosition.getStateMachineNode();
  
      // 1. Find possible paths.
      List<PathSegment> possiblePaths =
          find(currentPath, currentPosition, elemQName, 0);

      PathSegment nextPath = null;
  
      if ((possiblePaths != null) && !possiblePaths.isEmpty()) {

        /* 2. If multiple paths were returned, add a DecisionPoint.
         *    Sort the paths where paths ending in elements are favored over
         *    element wild cards, and shorter paths are favored over longer
         *    paths.
         */
        if (possiblePaths.size() > 1) {
          final DecisionPoint decisionPoint =
              new DecisionPoint(
                  currentPath,
                  possiblePaths,
                  traversedElements.size());

          if (decisionPoints == null) {
            decisionPoints = new ArrayList<DecisionPoint>(4);
          }
          decisionPoints.add(decisionPoint);

          nextPath = decisionPoint.tryNextPath();
        } else {
          nextPath = possiblePaths.get(0);
        }

        if (nextPath == null) {
          throw new IllegalStateException("When searching for " + elemQName + ", received a set of path choices of size " + possiblePaths.size() + ", but the next path is null.");
        }

        followPath(nextPath);

      } else {
        // OR: If no paths are returned:

        while ((decisionPoints != null) && !decisionPoints.isEmpty()) {
          /* 2a. Backtrack to the most recent decision point.
           *     Remove the top path (the one we just tried),
           *     and select the next one.
           */
          final DecisionPoint priorPoint =
              decisionPoints.get(decisionPoints.size() - 1);

          nextPath = priorPoint.tryNextPath();

          if (nextPath == null) {
            /* We have tried all paths at this decision point.
             * Remove it and try the next prior decision point.
             */
            decisionPoints.remove(decisionPoints.size() - 1);
            continue;
          }

          unfollowPriorPath( priorPoint.getDecisionPoint() );

          /* Walk through the traversedElements list again from that
           * index and see if we traverse through all of the elements
           * in the list, including this one.  If not, repeat step 2a,
           * removing decision points from the stack as we refute them.
           */
          followPath(nextPath);

          for (int index = priorPoint.traversedElementIndex + 1;
              index < traversedElements.size();
              ++index) {

            nextPath = null;

            final TraversedElement te = traversedElements.get(index);

            if (te.traversal.equals(TraversedElement.Traversal.START)) {
              possiblePaths =
                  find(
                      currentPath,
                      currentPosition,
                      traversedElements.get(index).elemName,
                      0);

              if ((possiblePaths == null) || possiblePaths.isEmpty()) {
                break;

              } else if (possiblePaths.size() > 1) {
                final DecisionPoint decisionPoint =
                    new DecisionPoint(
                        currentPath,
                        possiblePaths,
                        traversedElements.size() - 1);
                decisionPoints.add(decisionPoint);
                nextPath = decisionPoint.tryNextPath();

              } else {
                nextPath = possiblePaths.get(0);
              }

              if (nextPath == null) {
                throw new IllegalStateException("Somehow after finding a new path to follow, that path is null.");
              }

              // If we find (a) path(s) that match(es), success!  Follow it.
              followPath(nextPath);

            } else if ( te.traversal.equals(TraversedElement.Traversal.END) ) {
              walkUpTree(te.elemName);

            } else {
              throw new IllegalStateException("Unrecognized element traversal direction for " + te.elemName + " of " + te.traversal + '.');
            }
          }

          if ((possiblePaths == null) || possiblePaths.isEmpty()) {
            /* This attempt is also incorrect.  However, we may have introduced
             * new decision points along the way, and we want to follow them
             * first.  So let's go back around for another try.
             */
            continue;
          }
        }
      }

      if (nextPath != null) {
        traversedElements.add(
            new TraversedElement(elemQName, TraversedElement.Traversal.START));

      } else {
        /* If we go through all prior decision points and are unable to find
         * one or more paths through the XML Schema that match the document,
         * throw an error.  There is nothing more we can do here.
         */
        throw new IllegalStateException("Walked through XML Schema and could not find a traversal that represented this XML Document.");
      }

    } catch (Exception e) {
      throw new SAXException("Error occurred while starting element " + elemQName + "; traversed path is " + getElementsTraversedAsString(), e);
    }
  }

  /**
   * 
   * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)
   */
  @Override
  public void characters(char[] ch, int start, int length) throws SAXException {

    /* If the most recent path node is an element with simple content,
     * confirm these characters match the data type expected.
     *
     * If we are not expecting an element with simple content,
     * and the characters don't represent all whitespace, throw
     * an exception.
     */

    try {
      verifyCurrentPositionIsAtElement("Received characters");

      final SchemaStateMachineNode state =
          currentPosition.getStateMachineNode();

      /* If this represents a wildcard element, we don't
       * care - we won't be processing the content.
       */
      if ( state.getNodeType().equals(SchemaStateMachineNode.Type.ANY) ) {
        return;
      } else if (!state
                    .getElement()
                    .getQName()
                    .equals( traversedElements
                               .get(traversedElements.size() - 1)
                               .elemName) ) {

        throw new IllegalStateException("We are processing characters for " + traversedElements.get(traversedElements.size() - 1).elemName + " but our current position is for element " + state.getElement().getQName() + " !!");
      }

      final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();

      final String text = new String(ch, start, length).trim();

      final boolean elemExpectsContent =
          (elemTypeInfo != null) && (elemTypeInfo.getAvroType() != null);

      if (!elemExpectsContent && text.isEmpty()) {
        // Nothing to see here.
        return;

      } else if (!elemExpectsContent && !text.isEmpty()) {
        throw new IllegalStateException("Element " + state.getElement().getQName() + " has no content, but we received \"" + text + "\" for it.");

      } else if (elemExpectsContent
                   && text.isEmpty()
                   && !state.getElement().isNillable()) {
        // TODO: Also handle mixed content; some of it could be empty.

        throw new IllegalStateException("Received empty text for element " + state.getElement().getQName() + " when content was expected.");
      }

      /* TODO: Confirm the text conforms to the facets associated with the
       *       type.  This will require knowing if the type is a list or
       *       union, because rules like LENGTH, MIN_LENGTH, and MAX_LENGTH
       *       have different meanings based on the type.  This will have to
       *       wait until a refactor to remove the Avro-specific information
       *       from XmlSchemaTypeInfo.
       *
       *       This check likely belongs as a static method in the Utils class.
       */
      currentPosition.setReceivedContent(true);

      final XmlSchemaDocumentPathNode contentPath =
          createDocumentPathNode(
              XmlSchemaDocumentPathNode.Direction.CONTENT,
              currentPath,
              currentPosition);

      currentPath.setNextNode(-1, contentPath);
      currentPath = contentPath;

    } catch (Exception e) {
      throw new SAXException("Error occurred while processing characters; traversed path was " + getElementsTraversedAsString(), e);
    }
  }

  /**
   * Confirm the current position matches the element we are ending.
   * If not, throw an exception.
   *
   * If the number of occurrences is less than the minimum number of
   * occurrences, do not move.  The next element must be an instance
   * of this one.
   *
   * Otherwise, walk back up the tree to the next position.
   *
   * If the parent is a group of any kind, and its minimum number of
   * occurrences is not fulfilled, stop there.
   *
   * Otherwise, if the parent is a choice group or substitution group,
   * walk two levels up to the grandparent.  If the number of occurrences
   * of this element, the choice group, or the substitution group are
   * maxed out, and the grandparent is a sequence group or all group,
   * update the information accordingly.
   *
   * If the parent is a sequence group or an all group, update it
   * accordingly.  Again, if the number of occurrences is equal to
   * the maximum number, advance the parent accordingly.
   *
   * If the parent (or grandparent) is an element, return to it.
   * We expect the next call to be to endElement of that.
   *
   * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
   */
  @Override
  public void endElement(
      String uri,
      String localName,
      String qName)
      throws SAXException
  {
    final QName elemQName = new QName(uri, localName);

    try {
      verifyCurrentPositionIsAtElement("Ended element " + elemQName);

      final SchemaStateMachineNode state =
          currentPosition.getStateMachineNode();

      if ( state.getNodeType().equals(SchemaStateMachineNode.Type.ELEMENT) ) {

        // 1. Is this the element we are looking for?
        if (!state.getElement().getQName().equals(elemQName) ) {
          throw new IllegalStateException("We are ending element " + traversedElements.get(traversedElements.size() - 1).elemName + " but our current position is for element " + state.getElement().getQName() + " !!");
        }

        // 2. Check the element received the expected content, if any.
        final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();

        final boolean elemExpectsContent =
            (elemTypeInfo != null) && (elemTypeInfo.getAvroType() != null);

        if (elemExpectsContent
            && !state.getElement().isNillable()
            && !currentPosition.getReceivedContent()) {
          throw new IllegalStateException("We are ending element " + elemQName + "; it expected to receive content but did not.");
        }
      }

      walkUpTree(elemQName);

    } catch (Exception e) {
      throw new SAXException("Error occurred while ending element " + elemQName + "; traversed path was " + getElementsTraversedAsString(), e);
    }
  }

  @Override
  public void endDocument() throws SAXException {
    if (unusedNodePool != null) {
      unusedNodePool.clear();
    }

    if (unusedTreePool != null) {
      unusedTreePool.clear();
    }

    if (unusedPathSegmentPool != null) {
      unusedPathSegmentPool.clear();
    }

    if (decisionPoints != null) {
      decisionPoints.clear();
    }
  }

  XmlSchemaDocumentNode getXmlSchemaDocumentRoot() {
    return rootTreeNode;
  }

  XmlSchemaDocumentPathNode getXmlSchemaDocumentPath() {
    return rootPathNode;
  }

  private List<PathSegment> find(
      XmlSchemaDocumentPathNode startNode,
      XmlSchemaDocumentNode tree,
      QName elemQName,
      int currDepth) {

    if (currDepth > MAX_DEPTH) {
      /* We are likely in an infinite recursive loop looking for an element in
       * a group whose definition includes itself.  Likewise, we'll stop here
       * and say we were unable to find the element we were looking for.
       */
      return null;

    } else if (startNode.getStateMachineNode()
        != currentPosition.getStateMachineNode()) {

      throw new IllegalStateException("While searching for " + elemQName + ", the DocumentPathNode state machine (" + startNode.getStateMachineNode().getNodeType() + ") does not match the tree node (" + tree.getStateMachineNode().getNodeType() + ").");

    } else if (startNode.getIteration() != tree.getCurrIteration()) {
      throw new IllegalStateException("While searching for " + elemQName + ", the DocumentPathNode iteration (" + startNode.getIteration() + ") was not kept up-to-date with the tree node's iteration (" + tree.getCurrIteration() + ").  Current state machine position is " + tree.getStateMachineNode().getNodeType());

    } else if (tree
                 .getStateMachineNode()
                 .getNodeType()
                 .equals(SchemaStateMachineNode.Type.SEQUENCE)
        && (startNode.getIndexOfNextNodeState()
            != tree.getCurrPositionInSequence())) {

      throw new IllegalStateException("While processing a sequence group in search of " + elemQName + ", the current position in the DocumentPathNode (" + startNode.getIndexOfNextNodeState() + ") was not kept up-to-date with the tree node's position in the sequence group (" + tree.getCurrPositionInSequence() + ").");

    } else if (tree.getStateMachineNode().getMaxOccurs() < tree.getCurrIteration()) {

      throw new IllegalStateException("While searching for " + elemQName + " found that a node of type " + tree.getStateMachineNode().getNodeType() + " had more iterations in the tree (" + tree.getCurrIteration() + ") than were the maximum allowed for the state machine node (" + tree.getStateMachineNode().getMaxOccurs() + ").");

    } else if (tree.getStateMachineNode().getMaxOccurs() == tree.getCurrIteration()) {
      /* We already traversed this node the maximum number of times.
       * This path cannot be followed.
       */
      return null;
    }

    final SchemaStateMachineNode state = currentPosition.getStateMachineNode();

    // If this is a group, confirm it has children.
    if ( !state.getNodeType().equals(SchemaStateMachineNode.Type.ELEMENT)
        && !state.getNodeType().equals(SchemaStateMachineNode.Type.ANY) ) {

      if (( state.getPossibleNextStates() == null)
          || state.getPossibleNextStates().isEmpty()) {

        throw new IllegalStateException("Group " + state.getNodeType() + " has no children.  Found when processing " + elemQName);

      } else if (tree.getChildren() == null) {
        throw new IllegalStateException("StateMachineTreeWithState node represents a " + state.getNodeType() + ", but has no children.  Found when searching for " + elemQName);
      }

    }

    List<PathSegment> choices = null;

    switch (state.getNodeType()) {
    case ELEMENT:
      {
        if (state.getElement().getQName().equals(elemQName)
            && startNode.getIteration() < state.getMaxOccurs()) {

          choices = new ArrayList<PathSegment>(1);
          choices.add( createPathSegment(startNode) );
        }
      }
      break;

    case SEQUENCE:
      {
        // Find the next one in the sequence that matches.
        int position = tree.getCurrPositionInSequence();
        if (position < 0) {
          // Let's just do ourselves a favor and add in all the children now.
          if ( !tree.getChildren().isEmpty() ) {
            throw new IllegalStateException("When searching for " + elemQName + ", reached a sequence group with a negative position but with children defined.");
          }

          for (SchemaStateMachineNode nextState : state.getPossibleNextStates()) {
            tree.getChildren().add( createTreeNode(tree, nextState) );
          }

          position = 0;
        }

        for (int stateIndex = position;
            stateIndex < tree.getChildren().size();
            ++stateIndex) {

          // Process child.
          final XmlSchemaDocumentNode nextTree =
              tree.getChildren().get(stateIndex);

          final SchemaStateMachineNode nextState =
              nextTree.getStateMachineNode();

          final XmlSchemaDocumentPathNode nextPath =
              createDocumentPathNode(
                  XmlSchemaDocumentPathNode.Direction.CHILD,
                  startNode,
                  nextTree);
          nextPath.setIteration(nextTree.getCurrIteration());

          /* Both the tree node's and the document path node's state machine
           * nodes should point to the same state machine node in memory.
           */
          if ((nextTree.getStateMachineNode() != nextState)
              || (nextPath.getStateMachineNode() != nextState)) {
            throw new IllegalStateException("The expected state machine node (" + nextState.getNodeType() + ") does not match either the tree node (" + nextTree.getStateMachineNode().getNodeType() + ") or the next path (" + nextPath.getStateMachineNode().getNodeType() + ") when searching for " + elemQName);

          } else if (nextTree.getCurrIteration() >= nextState.getMaxOccurs()) {
            throw new IllegalStateException("Reached a sequence group when searching for " + elemQName + " whose iteration at the current position (" + nextTree.getCurrIteration() + ") was already maxed out (" + nextState.getMaxOccurs() + ").  Was at position " + stateIndex + "; tree node's starting position was " + tree.getCurrPositionInSequence());
          }

          final List<PathSegment> seqPaths =
              find(nextPath, nextTree, elemQName, currDepth + 1);

          if (seqPaths != null) {
            for (PathSegment seqPath : seqPaths) {
              seqPath.prepend(startNode, stateIndex);
            }

            // nextPath was cloned by all path segments, so it can be recycled.
            recyclePathNode(nextPath);

            if (choices == null) {
              choices = seqPaths;
            } else {
              choices.addAll(seqPaths);
            }
          }

          if (nextTree.getCurrIteration()
                < nextTree.getStateMachineNode().getMinOccurs()) {

            /* If we have not traversed this node in the sequence the minimum
             * number of times, we cannot advance to the next node in the
             * sequence.
             */
            break;
          }
        }

        break;
      }

    case ALL:
    case SUBSTITUTION_GROUP:
    case CHOICE:
      {
        /* All groups only contain elements.  Find one that matches.
         * The max-occurrence check will confirm it wasn't already selected.
         *
         * Choice groups may have multiple paths through its children
         * which are valid.  In addition, a wild card ("any" element)
         * may be a child of any group, thus creating another decision
         * point.
         */
        for (int stateIndex = 0;
            stateIndex < state.getPossibleNextStates().size();
            ++stateIndex) {

          final SchemaStateMachineNode nextState =
              state.getPossibleNextStates().get(stateIndex);

          if (state.getNodeType().equals(SchemaStateMachineNode.Type.ALL)
              && !nextState
                   .getNodeType()
                   .equals(SchemaStateMachineNode.Type.ELEMENT)
              && !nextState
                   .getNodeType()
                   .equals(SchemaStateMachineNode.Type.ANY)
              && !nextState
                   .getNodeType()
                   .equals(SchemaStateMachineNode.Type.SUBSTITUTION_GROUP)) {

            throw new IllegalStateException("While searching for " + elemQName + ", encountered an All group which contained a child of type " + nextState.getNodeType() + '.');
          }

          XmlSchemaDocumentNode nextTree = null;

          if (tree.getChildren().size() < stateIndex) {
            throw new IllegalStateException("In group of type " + state.getNodeType() + " when searching for " + elemQName + ", StateMachineTreeWithState contained fewer children (" + tree.getChildren().size() + ") than the next possible state index, " + stateIndex);

          } else if (tree.getChildren().size() == stateIndex) {
            nextTree = createTreeNode(tree, nextState);
            tree.getChildren().add(nextTree);

          } else {
            nextTree = tree.getChildren().get(stateIndex);
          }

          final XmlSchemaDocumentPathNode nextPath =
              createDocumentPathNode(
                  XmlSchemaDocumentPathNode.Direction.CHILD,
                  startNode,
                  nextTree);

          /* At this stage, we are only collecting possible paths to follow.
           * Likewise, we do not want to increment the iteration number yet
           * (or have any other side effects on the tree).
           */
          nextPath.setIteration(nextTree.getCurrIteration());

          /* Both the tree node's and the document path node's state machine
           * nodes should point to the same state machine node in memory.
           */
          if ((nextTree.getStateMachineNode() != nextState)
              || (nextPath.getStateMachineNode() != nextState)) {
            throw new IllegalStateException("The expected state machine node (" + nextState.getNodeType() + ") does not match either the tree node (" + nextTree.getStateMachineNode().getNodeType() + ") or the next path (" + nextPath.getStateMachineNode().getNodeType() + ") when searching for " + elemQName);
          }

          final List<PathSegment> choicePaths =
              find(nextPath, nextTree, elemQName, currDepth + 1);

          if (choicePaths != null) {
            for (PathSegment choicePath : choicePaths) {
              choicePath.prepend(startNode, stateIndex);
            }

            // nextPath was cloned by all path segments, so it can be recycled.
            recyclePathNode(nextPath);

            if (choices == null) {
              choices = choicePaths;
            } else {
              choices.addAll(choicePaths);
            }
          }
        }

        break;
      }
    case ANY:
      {
        /* If the XmlSchemaAny namespace and processing rules
         * apply, this element matches.  False otherwise.
         */
        if (traversedElements.size() < 2) {
          throw new IllegalStateException("Reached a wildcard element while searching for " + elemQName + ", but we've only seen " + traversedElements.size() + " element(s)!");
        }

        final XmlSchemaAny any = state.getAny();

        if (any.getNamespace() == null) {
          throw new IllegalStateException("The XmlSchemaAny element traversed when searching for " + elemQName + " does not have a namespace!");
        }

        boolean needTargetNamespace = false;
        boolean matches = false;

        List<String> validNamespaces = null;

        if ( any.getNamespace().equals("##any") ) {
          // Any namespace is valid.  This matches.
          matches = true;

        } else if ( any.getNamespace().equals("##other") ) {
          needTargetNamespace = true;
          validNamespaces = new ArrayList<String>(1);

        } else {
          final String[] namespaces = any.getNamespace().trim().split(" ");
          validNamespaces = new ArrayList<String>(namespaces.length);
          for (String namespace : namespaces) {
            if (namespace.equals("##targetNamespace")) {
              needTargetNamespace = true;

            } else if (namespace.equals("##local")
                && (elemQName.getNamespaceURI() == null)) {

              matches = true;

            } else {
              validNamespaces.add(namespace);
            }
          }
        }

        if (!matches) {
          /* At this time, it is not possible to determine the XmlSchemaAny's
           * original target namespace without knowing the original element
           * that owned it.  Likewise, unless the XmlSchemaAny's namespace is
           * an actual namespace, or ##any, or ##local, there is no way to
           * validate it.
           *
           * The work-around is to walk upwards through the tree and find
           * the owning element, then use its namespace as the target
           * namespace.
           */
          if (needTargetNamespace) {
            XmlSchemaDocumentNode iter = tree;
            while ( !iter
                      .getStateMachineNode()
                      .getNodeType()
                      .equals(SchemaStateMachineNode.Type.ELEMENT) ) {

              iter = iter.getParent();

              if (iter == null) {
                throw new IllegalStateException("Walking up the StateMachineTreeWithState to determine the target namespace of a wildcard element, and reached the root without finding any elements.  Searching for " + elemQName + '.');
              }
            }

            validNamespaces.add(
              iter
                .getStateMachineNode()
                .getElement()
                .getQName()
                .getNamespaceURI());
          }

          matches = validNamespaces.contains( elemQName.getNamespaceURI() );
        }

        if (matches) {
          choices = new ArrayList<PathSegment>(1);
          choices.add( createPathSegment(startNode) );
        }
      }
      break;
    default:
      throw new IllegalStateException("Unrecognized node type " + state.getNodeType() + " when processing element " + elemQName);
    }

    if (choices == null) {
      recyclePathNode(startNode);
    }
    return choices;
  }

  private void followPath(PathSegment path) {
    switch (path.getEnd().getStateMachineNode().getNodeType()) {
    case ELEMENT:
    case ANY:
      break;
    default:
      throw new IllegalStateException("Path does not end in an element or a wildcard element.");
    }

    // Join the start element with the new path.
    XmlSchemaDocumentPathNode iter = path.getStart();

    if (path.getAfterStart() != null) {
      iter.setNextNode(path.getAfterStartPathIndex(), path.getAfterStart());
    }

    // Walk the path and update the underlying document node accordingly.
    while (iter != null) {
      final XmlSchemaDocumentNode docNode = iter.getDocumentNode();

      // We only update when we're entering, not when we're leaving.
      if (iter
            .getDirection()
            .equals(XmlSchemaDocumentPathNode.Direction.CHILD)) {

        docNode.setCurrIteration(docNode.getCurrIteration() + 1);

        if (docNode.getCurrIteration()
            > docNode.getStateMachineNode().getMaxOccurs()) {

          final String elemName =
              getLeafNodeName( path.getEnd().getStateMachineNode() );
          throw new IllegalStateException("When walking the path to " + elemName + ", we incremented the iteration of a " + docNode.getStateMachineNode().getNodeType() + " (" + docNode.getCurrIteration() + ") beyond its maximum (" + docNode.getStateMachineNode().getMaxOccurs() + ").");
        }

        if (docNode
              .getStateMachineNode()
              .getNodeType()
              .equals(SchemaStateMachineNode.Type.SEQUENCE)) {

          docNode.setCurrPositionInSequence(iter.getIndexOfNextNodeState());
        }
      }

      iter = iter.getNext();
    }

    currentPath = path.getEnd();
    currentPosition = path.getEnd().getDocumentNode();

    // This path segment is followed!  We no longer need it.
    recyclePathSegment(path);
  }

  private void unfollowPriorPath(XmlSchemaDocumentPathNode start) {
    /* We need to walk from currentPosition back to start, undoing
     * iteration increments and sequence group walks along the way.
     */
    XmlSchemaDocumentPathNode revIter = currentPath;
    currentPath = start;
    currentPosition = start.getDocumentNode();

    while (revIter != start) {

      // As before, only entering counts; exiting does not.
      if (revIter
            .getDirection()
            .equals(XmlSchemaDocumentPathNode.Direction.CHILD)) {

        final XmlSchemaDocumentNode docNode = revIter.getDocumentNode();
        docNode.setCurrIteration(docNode.getCurrIteration() - 1);
        if (docNode
              .getStateMachineNode()
              .getNodeType()
              .equals(SchemaStateMachineNode.Type.SEQUENCE)) {

          int priorPosition = revIter.getPriorSequencePosition();
          if (priorPosition < 0) {
            /* A negative sequence position indicates that the sequence has not
             * been traversed yet, and children need to be created.  Since the
             * node has been traversed and children have been created, we just
             * want to indicate we're in the first position.
             */
            priorPosition = 0;
          }
          docNode.setCurrPositionInSequence(priorPosition);
        }
      }

      /* While this segment of the path is no longer valid, the underlying
       * document node is, and will likely be traversed again.  Likewise,
       * we only want to recycle the path node, and leave the document node
       * in place.
       */
      final XmlSchemaDocumentPathNode nodeToRecycle = revIter;
      revIter = revIter.getPrevious();
      recyclePathNode(nodeToRecycle);
    }
  }

  /* Walks up the tree from the current element to the prior one.
   * Confirms the provided QName matches the current one before traversing.
   *
   * If currElem is null, the current position must be a wildcard element.
   */
  private void walkUpTree(QName currElem) {
    final SchemaStateMachineNode state = currentPosition.getStateMachineNode();
    switch (state.getNodeType()) {
    case ANY:
      break;
    case ELEMENT:
      if ( !state.getElement().getQName().equals(currElem) ) {
        throw new IllegalStateException("We expected to walk upwards from element " + currElem + ", but our current element is " + state.getElement().getQName());
      }
      break;
    default:
      throw new IllegalStateException("We expected to walk upwards from element " + currElem + ", but our current position is in a node of type " + state.getNodeType());
    }

    XmlSchemaDocumentNode iter = currentPosition;
    XmlSchemaDocumentPathNode path = currentPath;

    do {
      iter = iter.getParent();

      // If iter is null, it means we ended the root, and we're done!
      if (iter == null) {
        break;
      }

      final XmlSchemaDocumentPathNode nextPath =
          createDocumentPathNode(
              XmlSchemaDocumentPathNode.Direction.PARENT,
              path,
              iter);

      path.setNextNode(-1, nextPath);
      path = nextPath;

    } while (!iter
                .getStateMachineNode()
                .getNodeType()
                .equals(SchemaStateMachineNode.Type.ELEMENT));

    currentPath = path;
    currentPosition = iter;
  }

  private XmlSchemaDocumentPathNode createDocumentPathNode(
      XmlSchemaDocumentPathNode.Direction direction,
      XmlSchemaDocumentPathNode previous,
      XmlSchemaDocumentNode state) {

    if ((unusedNodePool != null) && !unusedNodePool.isEmpty()) {
      XmlSchemaDocumentPathNode node = unusedNodePool.remove(unusedNodePool.size() - 1);
      node.update(direction, previous, state);
      return node;
    } else {
      return new XmlSchemaDocumentPathNode(direction, previous, state);
    }
  }

  private void recyclePathNode(XmlSchemaDocumentPathNode toReuse) {
    if (unusedNodePool == null) {
      unusedNodePool = new ArrayList<XmlSchemaDocumentPathNode>();
    }
    unusedNodePool.add(toReuse);
  }

  private XmlSchemaDocumentNode createTreeNode(
      XmlSchemaDocumentNode parent,
      SchemaStateMachineNode node) {

    if ((unusedTreePool == null) || unusedTreePool.isEmpty()) {
      return new XmlSchemaDocumentNode(parent, node);
    } else {
      XmlSchemaDocumentNode tree =
          unusedTreePool.remove(unusedTreePool.size() - 1);

      tree.set(parent, node);

      return tree;
    }
  }

  private void recycleTreeNode(XmlSchemaDocumentNode tree) {
    if (unusedTreePool == null) {
      unusedTreePool = new ArrayList<XmlSchemaDocumentNode>();
    }
    unusedTreePool.add(tree);
  }

  private PathSegment createPathSegment(XmlSchemaDocumentPathNode endPathNode) {
    PathSegment segment = null;
    if ((unusedPathSegmentPool != null) && !unusedPathSegmentPool.isEmpty()) {
      segment =
          unusedPathSegmentPool.remove(unusedPathSegmentPool.size() - 1);
      segment.set(endPathNode);

    } else {
      segment = new PathSegment(endPathNode);
    }
    return segment;
  }

  private void recyclePathSegment(PathSegment segment) {
    if (unusedPathSegmentPool == null) {
      unusedPathSegmentPool = new ArrayList<PathSegment>();
    }

    /* All of the path nodes inside the segment have been recycled already as
     * part of the call to unfollowPriorPath().  So we just need to recycle the
     * PathSegments themselves.
     */

    unusedPathSegmentPool.add(segment);
  }

  /* Perhaps this would be better implemented as a bunch of starting and
   * ending tags on separate lines, properly indented, to generate an XML
   * document similar to the one being parsed?  An idea to consider later.
   */
  private String getElementsTraversedAsString() {
    final StringBuilder traversed = new StringBuilder("[");
    if ((traversedElements != null) && !traversedElements.isEmpty()) {
      for (int i = 0; i < traversedElements.size() - 1; ++i) {
        traversed.append( traversedElements.get(i) ).append(" | ");
      }
      traversed.append( traversedElements.get(traversedElements.size() - 1) );
    }
    traversed.append(" ]");

    return traversed.toString();
  }

  private void verifyCurrentPositionIsAtElement(String errMsgPrefix) {
    if (!currentPosition
        .getStateMachineNode()
        .getNodeType()
        .equals(SchemaStateMachineNode.Type.ELEMENT)

        && !currentPosition
              .getStateMachineNode()
              .getNodeType()
              .equals(SchemaStateMachineNode.Type.ANY)) {

      throw new IllegalStateException(errMsgPrefix + " when our current position in the tree is a " + currentPosition.getStateMachineNode().getNodeType() + '.');
    }
  }

  private String getLeafNodeName(SchemaStateMachineNode node) {
    if (!node.getNodeType().equals(SchemaStateMachineNode.Type.ELEMENT)
        && !node.getNodeType().equals(SchemaStateMachineNode.Type.ANY)) {

      throw new IllegalStateException("State machine node needs to be an element or a wildcard element, not a " + currentPosition.getStateMachineNode().getNodeType() + '.');
    }

    String elemName = "a wildcard element";
    if (node.getNodeType().equals(SchemaStateMachineNode.Type.ELEMENT) ) {
      elemName =
          node.getElement().getQName().toString();
    }
    return elemName;
  }

  private final SchemaStateMachineNode rootNode;
  private XmlSchemaDocumentPathNode rootPathNode;
  private XmlSchemaDocumentNode rootTreeNode;

  private XmlSchemaDocumentNode currentPosition;
  private XmlSchemaDocumentPathNode currentPath;

  private List<XmlSchemaDocumentPathNode> unusedNodePool;
  private List<XmlSchemaDocumentNode> unusedTreePool;
  private List<PathSegment> unusedPathSegmentPool;

  private ArrayList<TraversedElement> traversedElements;
  private ArrayList<DecisionPoint> decisionPoints;
}
