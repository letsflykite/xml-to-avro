/**
 * Copyright 2014 Mike Pigott
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mpigott.avro.xml;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.xml.namespace.QName;

import org.apache.ws.commons.schema.XmlSchemaAny;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * Performs a SAX-based walk through the XML document, determining the
 * interpretation ("path") that best matches both the XML Schema and the
 * Avro Schema.
 *
 * @author  Mike Pigott
 */
final class XmlToAvroPathCreator extends DefaultHandler {

  /* If a group loops back on itself, we don't want to loop
   * until the stack overflows looking for a valid match.
   * We will stop looking once we reach MAX_DEPTH.
   */
  private static final int MAX_DEPTH = 256;

  /* We want to keep track of all of the valid path segments to a particular
   * element, but we do not want to stomp on the very first node until we
   * know which path we want to follow.  Likewise, we want to keep the
   * first node in the segment without a "next" node, but every node after
   * that we wish to chain together.
   *
   * To accomplish this, we start with a base node at the end and "prepend"
   * previous nodes until we work our way back to the beginning.  When we
   * prepend a node, we link the previous start node to the node directly
   * after it, while leaving the new start node unlinked.
   *
   * Path segments may also be recycled when a decision point is refuted.
   */
  private final class PathSegment implements Comparable<PathSegment> {
    PathSegment(XmlSchemaPathNode node) {
      set(node);
    }

    /**
     * The hash code is generated by walking all of the nodes in the path and
     * fetching a hash code for all of those, then summing it all together.
     */
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = prime + start.hashCode();

      if (afterStart != null) {
        for (XmlSchemaPathNode iter = afterStart;
            iter != null;
            iter = iter.getNext()) {
          result = prime * result + iter.hashCode();
        }
      }

      return result;
    }

    /**
     * Equality is checked by walking all of the nodes
     * in the path and checking equality on every node.
     */
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if (obj == null) {
        return false;
      } else if (!(obj instanceof PathSegment)) {
        return false;
      }

      final PathSegment other = (PathSegment) obj;

      if (start != other.getStart()) {
        /* PathSegments are implemented such that all common PathSegments
         * share the same start node in memory, but all following nodes in
         * the path are clones of each other.  Likewise, if the first nodes
         * do not point to the same memory location, these two paths cannot
         * be equivalent.
         */
        return false;

      } else if ((afterStart == null) && (other.getAfterStart() != null)) {
        return false;
      } else if ((afterStart != null) && (other.getAfterStart() == null)) {
        return false;
      } else if ((afterStart == null) && (other.getAfterStart() == null)) {
        return true;
      }

      XmlSchemaPathNode thisIter = afterStart;
      XmlSchemaPathNode thatIter = other.getAfterStart();

      while (thisIter != null) {
        if (thatIter == null) {
          return false;
        } else if ( !thisIter.equals(thatIter) ) {
          return false;
        }

        thisIter = thisIter.getNext();
        thatIter = thatIter.getNext();
      }

      if (thatIter != null) {
        return false;
      }

      return true;
    }

    @Override
    public int compareTo(PathSegment o) {
      if (this == o) {
        return 0;
      }

      /* Paths which end in a wildcard element are of lower
       * rank (higher order) than those that end in elements.
       */
      if ( !end
              .getStateMachineNode()
              .getNodeType()
              .equals( o.getEnd().getStateMachineNode().getNodeType() ) ) {

        if ( end
              .getStateMachineNode()
              .getNodeType()
              .equals(XmlSchemaStateMachineNode.Type.ANY) ) {
          return 1;

        } else if ( o.getEnd()
                     .getStateMachineNode()
                     .getNodeType()
                     .equals(XmlSchemaStateMachineNode.Type.ANY) ) {
          return -1;

        } else {
          throw new IllegalStateException("The end nodes do not have the same machine node type, so one should be an ELEMENT and the other should be an ANY.  However, this end node is a " + end.getStateMachineNode().getNodeType() + " while the other has an end node of type " + o.getEnd().getStateMachineNode().getNodeType() + ".");
        }
      }

      final int thisLength = getLength();
      final int thatLength = o.getLength();

      /* Paths that walk through earlier sequence group children are
       * preferred over paths that walk through later sequence group
       * children.  They provide more options later.
       *
       * Shorter paths are also preferred over longer ones.
       */
      if ((thisLength > 0) && (thatLength > 0)) {
        // Both paths have more than just one element.
        XmlSchemaPathNode thisIter = afterStart;
        XmlSchemaPathNode thatIter = o.getAfterStart();

        while ((thisIter != null) && (thatIter != null)) {
          if (thisIter.getIndexOfNextNodeState()
                < thatIter.getIndexOfNextNodeState()) {
            return -1;

          } else if (thisIter.getIndexOfNextNodeState()
                       > thatIter.getIndexOfNextNodeState()) {
            return  1;
          }

          thisIter = thisIter.getNext();
          thatIter = thatIter.getNext();
        }

        if ((thisIter == null) && (thatIter != null)) {
          // This path is shorter.
          return -1;
        } else if ((thisIter != null) && (thatIter == null)) {
          // That path is shorter.
          return 1;
        }

      } else if ((thisLength == 0) && (thatLength > 0)) {
        // This path is shorter.
        return -1;

      } else if ((thisLength > 0) && (thatLength == 0)) {
        // That path is shorter.
        return 1;

      } else {
        // Both paths have exactly one element.
        if (end.getIndexOfNextNodeState()
              < o.getEnd().getIndexOfNextNodeState()) {

          return -1;

        } else if (end.getIndexOfNextNodeState()
                     > o.getEnd().getIndexOfNextNodeState()) {

          return 1;
        }
      }

      /* If all of our different heuristics do not differentiate the
       * paths, we will return equality.  This is fine because
       * Collections.sort(List<T>) is stable, and will preserve the
       * ordering.
       */
      return 0;
    }

    int getLength() {
      if ((length == 0) && (start != end)) {
        for (XmlSchemaPathNode iter = afterStart;
            iter != end;
            iter = iter.getNext()) {
          ++length;
        }
        ++length; // (afterStart -> end) + start
      }
      return length;
    }

    /* Prepends a new start node to this segment.  We want to clone
     * the previous start node as sibling paths may be sharing it.
     * We also need to know the newStart's path index to reach the
     * clonedStartNode, so we know how to properly link them later.
     */
    void prepend(XmlSchemaPathNode newStart, int pathIndexToNextNode) {
      // We need to clone start and make it the afterStart.
      final XmlSchemaPathNode clonedStartNode = pathMgr.clone(start);

      if (afterStart != null) {
        afterStart.setPreviousNode(clonedStartNode);
        // TODO: clonedStartNode.setNextNode(afterStartPathIndex, afterStart);
        afterStart = clonedStartNode;

      } else {
        // This path segment only has one node in it; now it has two.
        end = clonedStartNode;
        afterStart = clonedStartNode;
      }

      start = newStart;
      afterStartPathIndex = pathIndexToNextNode;
      length = 0; // Force a recalculation.
    }

    XmlSchemaPathNode getStart() {
      return start;
    }

    XmlSchemaPathNode getEnd() {
      return end;
    }

    XmlSchemaPathNode getAfterStart() {
      return afterStart;
    }

    int getAfterStartPathIndex() {
      return afterStartPathIndex;
    }

    final void set(XmlSchemaPathNode node) {
      if (node == null) {
        throw new IllegalArgumentException("DocumentPathNode cannot be null.");
      }

      this.start = node;
      this.end = node;
      this.afterStart = null;
      this.afterStartPathIndex = -1;
      this.length = 0;
    }

    private XmlSchemaPathNode start;
    private XmlSchemaPathNode end;
    private XmlSchemaPathNode afterStart;
    private int length;
    private int afterStartPathIndex;
  }

  /**
   * A <code>DescisionPoint</code> is a location in a document path where
   * an element in the document can be reached by following two or more
   * different traversals through the XML Schema.
   *
   * When we reach such a decision point, we will keep track of the different
   * paths through the XML Schema that reach the element.  We will then follow
   * each path, one-by-one from the shortest through the longest, until we find
   * a path that successfully navigates both the document and the schema.
   */
  private static class DecisionPoint {
    DecisionPoint(
        XmlSchemaPathNode decisionPoint,
        List<PathSegment> choices,
        int traversedElementIndex) {

      if (decisionPoint == null) {
        throw new IllegalArgumentException("The decision point path node cannot be null.");
      } else if (choices == null) {
        throw new IllegalArgumentException("The set of choice paths to follow cannot be null.");
      } else if (choices.size() < 2) {
        throw new IllegalArgumentException("There must be at least two choices to constitute a decision point, not " + choices.size());
      }

      this.decisionPoint = decisionPoint;
      this.choices = choices;
      this.traversedElementIndex = traversedElementIndex;
      java.util.Collections.sort(choices);
    }

    /**
     * Returns the next <code>PathSegment</code> to try, or
     * <code>null</code> if all <code>PathSegment</code>s
     * have been followed.
     */
    PathSegment tryNextPath() {
      if (choices.isEmpty()) {
        return null;
      } else {
        return choices.remove(0);
      }
    }

    XmlSchemaPathNode getDecisionPoint() {
      return decisionPoint;
    }

    private final XmlSchemaPathNode decisionPoint;
    private final List<PathSegment> choices;
    private final int traversedElementIndex;
  }

  private static class TraversedElement {
    enum Traversal {
      START,
      END
    }

    TraversedElement(QName elemName, Traversal traversal) {
      this.elemName = elemName;
      this.traversal = traversal;
    }

    public String toString() {
      StringBuilder str = new StringBuilder( elemName.toString() );
      str.append(" : ").append(traversal);
      return str.toString();
    }

    QName elemName;
    Traversal traversal;
  }

  /**
   * Creates a new <code>XmlToAvroPathCreator</code> with the root
   * {@link XmlSchemaStateMachineNode} to start from when evaluating documents.
   */
  XmlToAvroPathCreator(XmlSchemaStateMachineNode root) {
    rootNode = root;
    rootTreeNode = null; // Will be created later.

    rootPathNode =
        new XmlSchemaPathNode(
            XmlSchemaPathNode.Direction.CHILD,
            null,
            rootNode);

    traversedElements = new ArrayList<TraversedElement>();
    elementStack = new ArrayList<QName>();
    currentPosition = null;
    currentPath = null;
    decisionPoints = null; // Hopefully there won't be any!

    pathMgr = new XmlSchemaPathManager();
    unusedPathSegmentPool = null;
  }

  @Override
  public void startDocument() throws SAXException {
    currentPosition = null;
    currentPath = null;

    traversedElements.clear();
    elementStack.clear();

    if (decisionPoints != null) {
      decisionPoints.clear();
    }
  }

  /**
   * Find the path through the XML Schema that best matches this element.
   *
   * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
   */
  @Override
  public void startElement(
      String uri,
      String localName,
      String qName,
      Attributes atts) throws SAXException {

    final QName elemQName = new QName(uri, localName);

    try {
      if ((currentPosition == null) && (currentPath == null)) {
        /* We just started a new document.  Likewise we need
         * to move into a position to process the root element.
         */
        currentPosition = rootTreeNode;
        currentPath = rootPathNode;

      } else if (currentPosition
                   .getStateMachineNode()
                   .getNodeType()
                   .equals(XmlSchemaStateMachineNode.Type.ANY)) {
        /* If we are currently following a wildcard element node, we don't know
         * anything about the element or its children.  So it does not make
         * sense to follow the children or grandchildren of this element.
         */
        return;

      } else if (
          currentPosition
            .getStateMachineNode()
            .getNodeType()
            .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
          && currentPosition
               .getStateMachineNode()
               .getElement()
               .getQName()
               .equals( elementStack.get(elementStack.size() - 1) )) {

        /* We are at an element in an existing document.  This
         * is the start node of a child.  Likewise we need to
         * move down one level to the children.
         */
        verifyCurrentPositionIsAtElement("Started element " + elemQName);

        if (currentPosition
             .getStateMachineNode()
             .getPossibleNextStates() == null) {

          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has null children!  Exactly one is expected.");

        } else if (currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates()
                  .isEmpty()) {

          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has zero children!  Exactly one is expected.");

        } else if (currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates().size() > 1) {

          final String elemName =
              getLeafNodeName( currentPosition.getStateMachineNode() );

          throw new IllegalStateException("Element " + elemName + " has " + currentPosition.getStateMachineNode().getPossibleNextStates().size() + " children!  Only one was expected.");
        }

        XmlSchemaDocumentNode childNode = null;
        if ((currentPosition.getChildren() != null)
          && !currentPosition.getChildren().isEmpty()) {

          if (currentPosition.getChildren().size() > 1) {
            throw new IllegalStateException("There are multiple children in the document node for element " + currentPosition.getStateMachineNode().getElement().getQName());
          }

          childNode = currentPosition.getChildren().get(0);

        } else {
          childNode =
            new XmlSchemaDocumentNode(
                currentPosition,
                currentPosition
                  .getStateMachineNode()
                  .getPossibleNextStates()
                  .get(0));
        }

        final XmlSchemaPathNode childPath =
            pathMgr.addChildNodeToPath(currentPath, 0);

        currentPosition.getChildren().put(0, childNode);
        currentPosition = childNode;

        // TODO: currentPath.setNextNode(0, childPath);
        currentPath = childPath;
        currentPath.setIteration( childNode.getIteration() );

        if (currentPosition
              .getStateMachineNode()
              .getNodeType()
              .equals(XmlSchemaStateMachineNode.Type.SEQUENCE)) {
        }
      }

      // 1. Find possible paths.
      List<PathSegment> possiblePaths = find(currentPath, elemQName);

      PathSegment nextPath = null;
  
      if ((possiblePaths != null) && !possiblePaths.isEmpty()) {

        /* 2. If multiple paths were returned, add a DecisionPoint.
         *    Sort the paths where paths ending in elements are favored over
         *    element wild cards, and shorter paths are favored over longer
         *    paths.
         */
        if (possiblePaths.size() > 1) {
          final DecisionPoint decisionPoint =
              new DecisionPoint(
                  currentPath,
                  possiblePaths,
                  traversedElements.size());

          if (decisionPoints == null) {
            decisionPoints = new ArrayList<DecisionPoint>(4);
          }
          decisionPoints.add(decisionPoint);

          nextPath = decisionPoint.tryNextPath();
        } else {
          nextPath = possiblePaths.get(0);
        }

        if (nextPath == null) {
          throw new IllegalStateException("When searching for " + elemQName + ", received a set of path choices of size " + possiblePaths.size() + ", but the next path is null.");
        }

        // TODO: followPath(nextPath);

      } else {
        // OR: If no paths are returned:

        while ((decisionPoints != null) && !decisionPoints.isEmpty()) {
          /* 2a. Backtrack to the most recent decision point.
           *     Remove the top path (the one we just tried),
           *     and select the next one.
           */
          final DecisionPoint priorPoint =
              decisionPoints.get(decisionPoints.size() - 1);

          nextPath = priorPoint.tryNextPath();

          if (nextPath == null) {
            /* We have tried all paths at this decision point.
             * Remove it and try the next prior decision point.
             */
            decisionPoints.remove(decisionPoints.size() - 1);
            continue;
          }

          // TODO: unfollowPriorPath( priorPoint.getDecisionPoint() );

          /* Walk through the traversedElements list again from that
           * index and see if we traverse through all of the elements
           * in the list, including this one.  If not, repeat step 2a,
           * removing decision points from the stack as we refute them.
           */
          // TODO: followPath(nextPath);

          for (int index = priorPoint.traversedElementIndex + 1;
              index < traversedElements.size();
              ++index) {

            nextPath = null;

            final TraversedElement te = traversedElements.get(index);

            if (te.traversal.equals(TraversedElement.Traversal.START)) {
              possiblePaths =
                  find(currentPath, traversedElements.get(index).elemName);

              if ((possiblePaths == null) || possiblePaths.isEmpty()) {
                break;

              } else if (possiblePaths.size() > 1) {
                final DecisionPoint decisionPoint =
                    new DecisionPoint(
                        currentPath,
                        possiblePaths,
                        traversedElements.size() - 1);
                decisionPoints.add(decisionPoint);
                nextPath = decisionPoint.tryNextPath();

              } else {
                nextPath = possiblePaths.get(0);
              }

              if (nextPath == null) {
                throw new IllegalStateException("Somehow after finding a new path to follow, that path is null.");
              }

              // If we find (a) path(s) that match(es), success!  Follow it.
              // TODO: followPath(nextPath);

            } else if ( te.traversal.equals(TraversedElement.Traversal.END) ) {
              // TODO: walkUpTree(te.elemName);

            } else {
              throw new IllegalStateException("Unrecognized element traversal direction for " + te.elemName + " of " + te.traversal + '.');
            }
          }

          if ((possiblePaths == null) || possiblePaths.isEmpty()) {
            /* This attempt is also incorrect.  However, we may have introduced
             * new decision points along the way, and we want to follow them
             * first.  So let's go back around for another try.
             */
            continue;
          }
        }
      }

      if (nextPath != null) {
        traversedElements.add(
            new TraversedElement(elemQName, TraversedElement.Traversal.START));
        elementStack.add(elemQName);
      } else {
        /* If we go through all prior decision points and are unable to find
         * one or more paths through the XML Schema that match the document,
         * throw an error.  There is nothing more we can do here.
         */
        throw new IllegalStateException("Walked through XML Schema and could not find a traversal that represented this XML Document.");
      }

    } catch (Exception e) {
      /* A SAX Exception cannot be thrown because it is caught, and its
       * internal exception is thrown instead. Likewise, any useful info
       * about the error reported in the wrapper SAXException is lost.
       */
      throw new RuntimeException("Error occurred while starting element " + elemQName + "; traversed path is " + getElementsTraversedAsString(), e);
    }

    //System.err.println( currentPosition.getStateMachineNode().getElement().getQName() );
  }

  /**
   * 
   * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)
   */
  @Override
  public void characters(char[] ch, int start, int length) throws SAXException {

    /* If the most recent path node is an element with simple content,
     * confirm these characters match the data type expected.
     *
     * If we are not expecting an element with simple content,
     * and the characters don't represent all whitespace, throw
     * an exception.
     */

    try {
      final XmlSchemaStateMachineNode state =
          currentPosition.getStateMachineNode();

      if ( state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ANY) ) {
        /* If this represents a wildcard element, we don't
         * care - we won't be processing the content.
         */
        return;

      } else if (!getQNameOfOwningElement()
                   .equals(elementStack.get(elementStack.size() - 1))) {

        throw new IllegalStateException("We are processing characters for " + elementStack.get(elementStack.size() - 1) + " but our current position is for element " + state.getElement().getQName() + " !!");
      }

      final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();

      final String text = new String(ch, start, length).trim();

      final boolean elemExpectsContent =
          (elemTypeInfo != null) && (elemTypeInfo.getAvroType() != null);

      if (!elemExpectsContent && text.isEmpty()) {
        // Nothing to see here.
        return;

      } else if (!elemExpectsContent && !text.isEmpty()) {
        throw new IllegalStateException("Element " + state.getElement().getQName() + " has no content, but we received \"" + text + "\" for it.");

      } else if (elemExpectsContent
                   && text.isEmpty()
                   && !state.getElement().isNillable()) {
        // TODO: Also handle mixed content; some of it could be empty.

        throw new IllegalStateException("Received empty text for element " + state.getElement().getQName() + " when content was expected.");
      }

      /* TODO: Confirm the text conforms to the facets associated with the
       *       type.  This will require knowing if the type is a list or
       *       union, because rules like LENGTH, MIN_LENGTH, and MAX_LENGTH
       *       have different meanings based on the type.  This will have to
       *       wait until a refactor to remove the Avro-specific information
       *       from XmlSchemaTypeInfo.
       *
       *       This check likely belongs as a static method in the Utils class.
       */
      currentPosition.setReceivedContent(true);

      final XmlSchemaPathNode contentPath =
          pathMgr.addParentSiblingOrContentNodeToPath(
              currentPath,
              XmlSchemaPathNode.Direction.CONTENT);

      // TODO: currentPath.setNextNode(-1, contentPath);
      currentPath = contentPath;

    } catch (Exception e) {
      throw new RuntimeException("Error occurred while processing characters; traversed path was " + getElementsTraversedAsString(), e);
    }
  }

  /**
   * Confirm the current position matches the element we are ending.
   * If not, throw an exception.
   *
   * If the number of occurrences is less than the minimum number of
   * occurrences, do not move.  The next element must be an instance
   * of this one.
   *
   * Otherwise, walk back up the tree to the next position.
   *
   * If the parent is a group of any kind, and its minimum number of
   * occurrences is not fulfilled, stop there.
   *
   * Otherwise, if the parent is a choice group or substitution group,
   * walk two levels up to the grandparent.  If the number of occurrences
   * of this element, the choice group, or the substitution group are
   * maxed out, and the grandparent is a sequence group or all group,
   * update the information accordingly.
   *
   * If the parent is a sequence group or an all group, update it
   * accordingly.  Again, if the number of occurrences is equal to
   * the maximum number, advance the parent accordingly.
   *
   * If the parent (or grandparent) is an element, return to it.
   * We expect the next call to be to endElement of that.
   *
   * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
   */
  @Override
  public void endElement(
      String uri,
      String localName,
      String qName)
      throws SAXException
  {
    final QName elemQName = new QName(uri, localName);

    try {
      verifyCurrentPositionIsAtElement("Ended element " + elemQName);

      if ( !elementStack.get(elementStack.size() - 1).equals(elemQName) ) {
        throw new IllegalStateException("Attempting to end element " + elemQName + " but the stack is expecting " + elementStack.get(elementStack.size() - 1));
      }

      final XmlSchemaStateMachineNode state =
          currentPosition.getStateMachineNode();

      if ( state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT) ) {

        // 1. Is this the element we are looking for?
        if (!state.getElement().getQName().equals(elemQName) ) {
          throw new IllegalStateException("We are ending element " + traversedElements.get(traversedElements.size() - 1).elemName + " but our current position is for element " + state.getElement().getQName() + " !!");
        }

        // 2. Check the element received the expected content, if any.
        final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();

        final boolean elemExpectsContent =
            (elemTypeInfo != null) && (elemTypeInfo.getAvroType() != null);

        if (elemExpectsContent
            && !state.getElement().isNillable()
            && !currentPosition.getReceivedContent()) {
          throw new IllegalStateException("We are ending element " + elemQName + "; it expected to receive content but did not.");
        }
      }

      // TODO: walkUpTree(elemQName);

      traversedElements.add(
          new TraversedElement(elemQName, TraversedElement.Traversal.END));
      elementStack.remove(elementStack.size() - 1);

    } catch (Exception e) {
      throw new RuntimeException("Error occurred while ending element " + elemQName + "; traversed path was " + getElementsTraversedAsString(), e);
    }
  }

  @Override
  public void endDocument() throws SAXException {
    pathMgr.clear();

    if (unusedPathSegmentPool != null) {
      unusedPathSegmentPool.clear();
    }

    if (decisionPoints != null) {
      decisionPoints.clear();
    }
  }

  XmlSchemaDocumentNode getXmlSchemaDocumentRoot() {
    return rootTreeNode;
  }

  XmlSchemaPathNode getXmlSchemaDocumentPath() {
    return rootPathNode;
  }

  private boolean isCurrentPositionFulfilled() {
    final XmlSchemaStateMachineNode state = currentPosition.getStateMachineNode();

    final List<XmlSchemaStateMachineNode> nextStates =
        state.getPossibleNextStates();

    final Map<Integer, XmlSchemaDocumentNode> children =
        currentPosition.getChildren();

    boolean fulfilled = true;

    switch ( state.getNodeType() ) {
    case ELEMENT:
    case ANY:
      // We only need to perform the occurrence check.
      break;
    case CHOICE:
    case SUBSTITUTION_GROUP:
      {
        // If any child meets the minimum number, we succeeded.
        fulfilled = false;
        for (int stateIndex = 0;
            stateIndex < nextStates.size();
            ++stateIndex) {

          XmlSchemaStateMachineNode nextState = nextStates.get(stateIndex);

          if ( children.containsKey(stateIndex) ) {
            final XmlSchemaDocumentNode child = children.get(stateIndex);
            if (child.getIteration()
                >= nextState.getMinOccurs()) {
              fulfilled = true;
              break;
            }
          } else if (nextState.getMinOccurs() == 0) {
            fulfilled = true;
            break;
          }
        }
        break;
      }
    case ALL:
      {
        // If all children meet the minimum number, we succeeded.
        for (int stateIndex = 0;
            stateIndex < nextStates.size();
            ++stateIndex) {

          final XmlSchemaStateMachineNode nextState = nextStates.get(stateIndex);
          if (children.containsKey(stateIndex)) {
            final XmlSchemaDocumentNode child = children.get(stateIndex);
            if (child.getIteration()
                < nextState.getMinOccurs()) {
              fulfilled = false;
              break;
            }
          } else if (nextState.getMinOccurs() > 0) {
            fulfilled = false;
            break;
          }
        }

        break;
      }
    case SEQUENCE:
      {
        // If the sequence is complete, we succeeded.
        int stateIndex = currentPosition.getSequencePosition();
        if (stateIndex < 0) {
          stateIndex = 0;
        }
        for (; stateIndex < nextStates.size(); ++stateIndex) {

          final XmlSchemaStateMachineNode nextState = nextStates.get(stateIndex);
          if (children.containsKey(stateIndex)) {
            final XmlSchemaDocumentNode child = children.get(stateIndex);
            if (child.getIteration()
                < nextState.getMinOccurs()) {
              fulfilled = false;
              break;
            }
          } else if (nextState.getMinOccurs() > 0) {
            fulfilled = false;
            break;
          }
        }
        break;
      }
    default:
      throw new IllegalStateException("Current position has a node of unrecognized type \"" + currentPosition.getStateMachineNode().getNodeType() + '\"');
    }

    if (currentPosition == null) {
      // This is the root node.  It is not fulfilled.
      fulfilled = false;
    } else if ( currentPosition.getIteration() >= state.getMinOccurs() ) {
      fulfilled &= true;
    } else {
      fulfilled = false;
    }

    return fulfilled;
  }

  private List<PathSegment> find(
      XmlSchemaPathNode startNode,
      QName elemQName) {

    // First, try searching down the tree.
    List<PathSegment> choices = find(startNode, elemQName, 0);

    // Second, if the node is currently fulfilled, try siblings and parents.
    if ( isCurrentPositionFulfilled() ) {
      List<PathSegment> currChoices = null;

      // Try siblings.
      if (startNode.getIteration() < startNode.getMaxOccurs()) {
        XmlSchemaPathNode siblingPath =
            pathMgr.addParentSiblingOrContentNodeToPath(
                startNode,
                XmlSchemaPathNode.Direction.SIBLING);

        currChoices = find(siblingPath, elemQName, 0);
        if (currChoices != null) {
          for (PathSegment choice : currChoices) {
            choice.prepend(startNode, -1);
          }

          if (choices == null) {
            choices = currChoices;
          } else {
            choices.addAll(currChoices);
          }
        }
      }

      // Try parents.
      if (startNode.getDocumentNode().getParent() == null) {
        // This is the root element; there is no parent.
        return choices;
      }

      ArrayList<XmlSchemaPathNode> parentPathStack =
          new ArrayList<XmlSchemaPathNode>();

      parentPathStack.add(startNode);

      XmlSchemaPathNode path =
          pathMgr.addParentSiblingOrContentNodeToPath(
              startNode,
              XmlSchemaPathNode.Direction.PARENT);

      parentPathStack.add(path);

      /* We may continue traversing up the tree and collecting
       * choices until we reach our owning element.
       */
      while (!path
                .getStateMachineNode()
                .getNodeType()
                .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
               || !path
                     .getStateMachineNode()
                     .getElement()
                     .getQName()
                     .equals(elementStack.get(elementStack.size() - 1))) {

        currChoices = find(path, elemQName, 0);

        if (currChoices != null) {
          for (PathSegment currChoice : currChoices) {

            for (int parentIndex = parentPathStack.size() - 2;
                parentIndex >= 0;
                --parentIndex) {

              /* We need to prepend all of the nodes in the path that we
               * traversed to get to this level.  The most recent node
               * we traversed was already prepended, so we start from
               * the one before it.
               */
              currChoice.prepend(parentPathStack.get(parentIndex), -1);
            }
          }

          if (choices == null) {
            choices = currChoices;
          } else {
            choices.addAll(currChoices);
          }
        }

        final XmlSchemaPathNode nextPath =
            pathMgr.addParentSiblingOrContentNodeToPath(
                path,
                XmlSchemaPathNode.Direction.PARENT);

        path = nextPath;
        parentPathStack.add(path);
      }

    }

    return choices;
  }

  private List<PathSegment> find(
      XmlSchemaPathNode startNode,
      QName elemQName,
      int currDepth) {

    final XmlSchemaStateMachineNode state = startNode.getStateMachineNode();

    if (currDepth > MAX_DEPTH) {
      /* We are likely in an infinite recursive loop looking for an element in
       * a group whose definition includes itself.  Likewise, we'll stop here
       * and say we were unable to find the element we were looking for.
       */
      return null;

    } else if (startNode.getStateMachineNode() != state) {

      throw new IllegalStateException("While searching for " + elemQName + ", the DocumentPathNode state machine (" + startNode.getStateMachineNode().getNodeType() + ") does not match the tree node (" + state.getNodeType() + ").");

    } else if (startNode.getIteration()
                 <= startNode.getDocumentNode().getIteration()) {
      throw new IllegalStateException("While searching for " + elemQName + ", the DocumentPathNode iteration (" + startNode.getIteration() + ") should be greater than the tree node's iteration (" + startNode.getDocumentNode().getIteration() + ").  Current state machine position is " + state.getNodeType());

    } else if (state
                 .getNodeType()
                 .equals(XmlSchemaStateMachineNode.Type.SEQUENCE)
        && (startNode.getIndexOfNextNodeState()
            != startNode.getDocumentNode().getSequencePosition())) {

      // TODO: Is this a good / valid check?
      throw new IllegalStateException("While processing a sequence group in search of " + elemQName + ", the current position in the DocumentPathNode (" + startNode.getIndexOfNextNodeState() + ") was not kept up-to-date with the tree node's position in the sequence group (" + startNode.getDocumentNode().getSequencePosition() + ").");

    } else if (state.getMaxOccurs() < startNode.getIteration()) {
      System.err.println("Path to " + state.getNodeType() + " was already followed the max number of times.");
      return null;
    }

    // If this is a group, confirm it has children.
    if ( !state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
        && !state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ANY) ) {

      if (( state.getPossibleNextStates() == null)
          || state.getPossibleNextStates().isEmpty()) {

        throw new IllegalStateException("Group " + state.getNodeType() + " has no children.  Found when processing " + elemQName);
      }

    }

    List<PathSegment> choices = null;

    return choices;
  }

  private PathSegment createPathSegment(XmlSchemaPathNode endPathNode) {
    PathSegment segment = null;
    if ((unusedPathSegmentPool != null) && !unusedPathSegmentPool.isEmpty()) {
      segment =
          unusedPathSegmentPool.remove(unusedPathSegmentPool.size() - 1);
      segment.set(endPathNode);

    } else {
      segment = new PathSegment(endPathNode);
    }
    return segment;
  }

  private void recyclePathSegment(PathSegment segment) {
    if (unusedPathSegmentPool == null) {
      unusedPathSegmentPool = new ArrayList<PathSegment>();
    }

    /* All of the path nodes inside the segment have been recycled already as
     * part of the call to unfollowPriorPath().  So we just need to recycle the
     * PathSegments themselves.
     */

    unusedPathSegmentPool.add(segment);
  }

  /* Perhaps this would be better implemented as a bunch of starting and
   * ending tags on separate lines, properly indented, to generate an XML
   * document similar to the one being parsed?  An idea to consider later.
   */
  private String getElementsTraversedAsString() {
    final StringBuilder traversed = new StringBuilder("[");
    if ((traversedElements != null) && !traversedElements.isEmpty()) {
      for (int i = 0; i < traversedElements.size() - 1; ++i) {
        traversed.append( traversedElements.get(i) ).append(" | ");
      }
      traversed.append( traversedElements.get(traversedElements.size() - 1) );
    }
    traversed.append(" ]");

    return traversed.toString();
  }

  private void verifyCurrentPositionIsAtElement(String errMsgPrefix) {
    if (!currentPosition
        .getStateMachineNode()
        .getNodeType()
        .equals(XmlSchemaStateMachineNode.Type.ELEMENT)

        && !currentPosition
              .getStateMachineNode()
              .getNodeType()
              .equals(XmlSchemaStateMachineNode.Type.ANY)) {

      throw new IllegalStateException(errMsgPrefix + " when our current position in the tree is a " + currentPosition.getStateMachineNode().getNodeType() + '.');
    }
  }

  private String getLeafNodeName(XmlSchemaStateMachineNode node) {
    if (!node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
        && !node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ANY)) {

      throw new IllegalStateException("State machine node needs to be an element or a wildcard element, not a " + currentPosition.getStateMachineNode().getNodeType() + '.');
    }

    String elemName = "a wildcard element";
    if (node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT) ) {
      elemName =
          node.getElement().getQName().toString();
    }
    return elemName;
  }

  private QName getQNameOfOwningElement() {
    XmlSchemaDocumentNode iter = currentPosition;

    while ((iter != null)
            && !iter
                 .getStateMachineNode()
                 .getNodeType()
                 .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
      iter = iter.getParent();
    }

    if (iter == null) {
      return null;
    } else {
      return iter.getStateMachineNode().getElement().getQName();
    }
  }

  private final XmlSchemaStateMachineNode rootNode;
  private XmlSchemaPathNode rootPathNode;
  private XmlSchemaDocumentNode rootTreeNode;

  private XmlSchemaDocumentNode currentPosition;
  private XmlSchemaPathNode currentPath;

  private List<PathSegment> unusedPathSegmentPool;

  private ArrayList<TraversedElement> traversedElements;
  private ArrayList<DecisionPoint> decisionPoints;

  private ArrayList<QName> elementStack;

  private XmlSchemaPathManager pathMgr;
}
